import cv2import numpy as npimport numpy.random as randomimport numpy.linalg as linalgimport osimport mathimport matplotlib.pyplot as pltrows = 512cols = 512pixels = rows * colsclass BaseModel:    def __init__(self):        pass    def train(self, train_imgs, labels):        raise NotImplementedError    def detect(self, img):        raise NotImplementedErrorclass Eigenface(BaseModel):    def __init__(self, K:int = 20):        super(Eigenface, self).__init__()        self.K = K    def train(self, train_imgs, labels):        self.labels = labels        self.mean_imgs = np.mean(train_imgs, axis=0)        res = train_imgs - self.mean_imgs  # N, H*W        C = res @ res.T / train_imgs.shape[0]  # N, N        evalues, evectors = linalg.eig(C)        sort_indices = np.argsort(evalues)[::-1][:self.K]  #        self.U = res.T @ evectors[:, sort_indices]  # H*W, K        self.train_set = res @ self.U  # N, K    def detect(self, img:np.ndarray):        """        detection        :param img: M, H*W array        :return:            labels (M, )        """        img = img - self.mean_imgs # M, H*W        feature_L = img @ self.U # M, K Project images into feature space        # compute l2 distances        dis = linalg.norm(feature_L[:, np.newaxis, :] - self.train_set[np.newaxis, :, :], axis=2) # M, N        # make predictions        cls = np.argmin(dis, axis=1)        return self.labels[cls]def metric(val_dir, model):    face_dir = val_dir    labels = []    faces_path = sorted(os.listdir(face_dir))    face_count = len(faces_path)    L = np.empty(shape=(face_count, pixels), dtype=np.float64)    for idx, img_path in enumerate(faces_path):        img_full_path = os.path.join(face_dir, img_path)        img = cv2.imread(img_full_path, 0)  # read grey img        if img is None:            print("%s is not a valid img" % (img_full_path))        L[idx, :] = img.astype(np.float64).flatten()        labels.append(idx)    pred = model.detect(L)    tp = np.sum(pred == labels)    acc = tp / face_count    print("accu is %f"%(acc))def metric_mask_200_300(val_dir, model, begin=200, end=300, save_dir='./extra_200'):    face_dir = val_dir    labels = []    if not os.path.exists(save_dir):        os.mkdir(save_dir)    faces_path = sorted(os.listdir(face_dir))    face_count = len(faces_path)    L = np.empty(shape=(face_count, pixels), dtype=np.float64)    for idx, img_path in enumerate(faces_path):        img_full_path = os.path.join(face_dir, img_path)        img = cv2.imread(img_full_path, 0)  # read grey img        if img is None:            print("%s is not a valid img" % (img_full_path))        img[begin:end, :] = 0        cv2.imwrite(os.path.join(save_dir,img_path), img)        L[idx, :] = img.astype(np.float64).flatten()        labels.append(idx)    pred = model.detect(L)    tp = np.sum(pred == labels)    acc = tp / face_count    print("accu is %f"%(acc))class Trainer:    rows = 512    cols = 512    pixels = rows * cols    def __init__(self, face_dir, train=0.6):        self.face_dir = face_dir        self.training_ids = []        self.labels = []        self.faces_path = sorted(os.listdir(self.face_dir))        self.face_count = len(self.faces_path)        self.train_face_count = math.floor(self.face_count * train)        self.val_face_count = self.face_count - self.train_face_count        L = np.empty(shape=(self.face_count, self.pixels), dtype=np.float64) # N, H*W        for idx, img_path in enumerate(self.faces_path):            img_full_path = os.path.join(self.face_dir, img_path)            img = cv2.imread(img_full_path, 0) # read grey img            if img is None:                print("%s is not a valid img"%(img_full_path))            L[idx, :] = img.astype(np.float64).flatten()            self.labels.append(idx)        # shuffle_idx = np.arange(self.face_count)        # random.shuffle(shuffle_idx)        # self.train_imgs = L[shuffle_idx[:self.train_face_count], :]        # self.val_imgs = L[shuffle_idx[self.train_face_count:], :]        self.train_imgs = L        self.labels = np.array(self.labels)    def fit(self, model: BaseModel):        model.train(self.train_imgs, self.labels)if __name__=='__main__':    trainer = Trainer('./with_mask_100', 0.8)    model = Eigenface(K = 50)    trainer.fit(model)    metric('./without_mask_100', model)    metric_mask_200_300('./without_mask_100', model, 200, 300, './extra_200')